<!DOCTYPE html>
<html>
<head>
	<meta charset='utf-8'>
	<meta name='viewport' content='width=device-width, initial-scale=1.0'>
	<title>Open City test</title>

	<script type='text/javascript' src='../../../_01_libs/d3.min.js'></script>
	<script type='text/javascript' src='../../../_01_libs/topojson.min.js'></script>

	<script type='text/javascript' src='../../../_01_libs/base.fn.js'></script>

	<link href='https://fonts.googleapis.com/css?family=Asap+Condensed' rel='stylesheet'>

	<link rel='stylesheet' type='text/css' href='css/main.css'>
</head>

<body>


<script type='text/javascript'>

	var montagnes = {}
		montagnes.w = width() * resolution(),
		montagnes.h = height() * resolution(),
		montagnes.p = .3
		montagnes.perspective = 5
	var menu = {},
		toggle = {},
		mouse = {}
	var carte = {}
	var raisonnement = {}


	d3.queue()
	.defer(d3.csv, '../../../data/csv/autonomie.csv')
	.defer(d3.json, '../../../data/csv/meta-2.json')
	.defer(d3.json, '../../../data/unprojected/limites_intercommunalites.json')
	.await(function (err, data, meta, map) {
		if (err) throw err

		montagnes.data = data.filter(function (d) { return ['Total Isère', 'Bénéficiaires hors Isère'].indexOf(d.Commune) === -1  })
		montagnes.data.forEach(function (d) {
			d.Commune_strip = d.Commune.replace(/[éèœà]/g, '')
		})
		montagnes.communes = montagnes.data.map(function (d) { return d.Commune_strip })

		montagnes.xscale = d3.scaleBand()
			.domain(montagnes.data.map(function (d) { return d.Commune }))
			.rangeRound([montagnes.w * montagnes.p, montagnes.w - montagnes.w * montagnes.p])
			.padding(.1)
		montagnes.trackline = d3.line()
			.x(function (d) { return d[0] })
			.y(function (d) { return d[1] })
			//.curve(d3.curveNatural)
			.curve(d3.curveMonotoneY)

		console.log(montagnes.communes)

		menu.indicateurs = data.columns
		menu.indicateurs.splice(menu.indicateurs.indexOf('Commune'), 1)
		menu.indicateurs.splice(menu.indicateurs.indexOf('Ref'), 1)
		menu.indicateurs.splice(menu.indicateurs.indexOf('Commune_court'), 1)
		menu.indicateurs.splice(menu.indicateurs.indexOf('Commune_strip'), 1)

		montagnes.meta = meta.autonomie
		montagnes.indicateurs = []
		montagnes.background = []
		montagnes.foreground = []
		montagnes.perspective = { x: 0, y: 0 } 

		console.log(map)

		//carte.data = topojson.feature(map, map.objects.limites_communautes_pl)
		carte.data = topojson.feature(map, map.objects.limites_intercommunalites)

		console.log(carte.data)

		mouse.yscale = d3.scaleLinear()
			.domain([montagnes.h - montagnes.h * montagnes.p, 0])
			.range([0, 20])
			.clamp(true)

		var svg = d3.select('body').append('svg')
			.attr('class', 'paysage')
			.attr('width', montagnes.w)
			.attr('height', montagnes.h)
		.on('mousemove', function () {

			montagnes.perspective = {
				x: ((d3.event.x - montagnes.w / 2)) / 30,
				y: mouse.yscale(d3.event.y) //(((d3.event.y - montagnes.h / 2) / 30) < 0) ? Math.abs((d3.event.y - montagnes.h / 2)) / 30 : 0
			}
			d3.selectAll('.mont')
				.attr('transform', function (d) {
					if (!montagnes.background.length) return 'translate(' + [0, 0] + ')'
					
					// FOR THIS PART, NEED TO CLEAN THE MAP DATA FILE
					/*var communestr = d.Commune.replace(/[éèœ]/g, ''),
						territoire = carte.data.features.filter(function (c) { return c.properties.NOM === communestr })
						bounds = territoire.length ? carte.path.bounds(territoire[0]) : [0, 0],
						centroid = territoire.length ? carte.path.centroid(territoire[0]) : [0, 0]*/

					var b = d3.sum(montagnes.background.map(function (c) { return montagnes.yscale(parseFloat(d.data[c])) }))
					return 'translate(' + [b / 2, (d.index - montagnes.data.length / 2) * montagnes.perspective.y] + ')'
				})
		})
		
		var defs = svg.append('defs')
		var gradient = defs.append('radialGradient')
			.attr('id', 'base-gradient')
			.attr('cx', '0%')
			.attr('cy', '100%')
			.attr('r', '200%')
			.attr('fx', '25%')
		gradient.append('stop')
			.attr('offset', '0%')
			.attr('stop-color', 'rgba(240,248,255,1)')
		gradient.append('stop')
			.attr('offset', '100%')
			.attr('stop-color', 'rgba(112,128,144,1)')

		montagnes.draw()
		menu.draw()
		carte.draw()
		raisonnement.draw()
	})

	montagnes.draw = function () {
		
		montagnes.yscale = d3.scaleLinear()
			.domain([0, d3.max(montagnes.data.filter(function (d) { return montagnes.communes.indexOf(d.Commune_strip) !== -1 }), function (d) { return d3.max(montagnes.background.map(function (c) { return parseFloat(d[c]) })) })])
			.rangeRound([0, -(montagnes.h - (montagnes.h * montagnes.p) * 2)])
		
		montagnes.data.sort(function (a, b) { 
			var a_ = d3.mean(montagnes.background.map(function (d) { return a[d] })),
				b_ = d3.mean(montagnes.background.map(function (d) { return b[d] }))
			return b_ - a_
		})

		var svg = d3.select('svg.paysage'),
			mtns = svg.selectAll('g.pic')
				.data(montagnes.data.filter(function (d) { return montagnes.communes.indexOf(d.Commune_strip) !== -1 }), function (d) { return d.Commune_strip })

		mtns.exit().remove()

		var mtns_enter = mtns.enter()
			.append('g')
			.attr('class', 'pic')
			.attr('transform', function (d, i) { return 'translate(' + [montagnes.xscale(d.Commune), montagnes.h - montagnes.h * montagnes.p] + ')' })
		
		mtns_enter = mtns_enter.merge(mtns)
			.moveToFront()

		var pic = mtns_enter.selectAll('g.mont')
			.data(function (d, i) { return [{ data: d, index: i }] })
		
		pic.exit()
			.remove()

		var pic_enter = pic.enter()
			.append('g')
			.attr('class', 'mont')

		pic_enter = pic_enter.merge(pic)
			
		pic_enter.transition()
			.duration(1000)
			.ease(d3.easeCubic)
			.attr('transform', function (d) {
				if (!montagnes.background.length) return 'translate(' + [0, 0] + ')'
				var b = d3.sum(montagnes.background.map(function (c) { return montagnes.yscale(parseFloat(d.data[c])) }))
				return 'translate(' + [b / 2, (d.index - montagnes.data.length / 2) * montagnes.perspective.y] + ')'
			})

		var path = pic_enter.selectAll('path.background')
			.data(function (d, i) { return [{ data: d.data, index: d.index }] })

		path.exit()
			.remove()
		
		var path_enter = path.enter()
			.append('path')
			.attr('class', 'background')
		
		path_enter = path_enter.merge(path)
			
		path_enter.transition()
			.duration(1000)
			.ease(d3.easeCubic)
			.attr('d', function (d) { 

				var s = '',
					o = 0

				d.data.oa = []

				montagnes.background.forEach(function (c, j) {
				
					if (!isNaN(parseFloat(d.data[c]))) {
						
						var p = montagnes.yscale(parseFloat(d.data[c])),
							sib = montagnes.meta[c].relationships.siblings,
							parent = montagnes.meta[c].relationships.parent

						if (montagnes.background.length > 1) {

							var pi = {}
							
							if (j < montagnes.background.length - 1) {

								var p_ = montagnes.yscale(parseFloat(d.data[montagnes.background[j + 1]])),
									parent_ = montagnes.meta[montagnes.background[j + 1]].relationships.parent,
									//issib = sib.indexOf(montagnes.background[j + 1]) !== -1 || parent === parent_ || c === parent_ ? true : false
									issib = sib.indexOf(montagnes.background[j + 1]) !== -1 ? true : false
								
								// CHECK IF SAME CATEGORY
								var m = montagnes.meta[c].categories,
									m_ = montagnes.meta[montagnes.background[j + 1]].categories
								var ke = [], km
								
								for (var k in m) {
									
									var v = m[k],
										v_ = m_[k]
									ke.push(v.key === v_.key)
								
								}
								
								km = ke.indexOf(true) === 0 ? true : false
								ke = ke.indexOf(false) === -1 ? true : false

								if (Math.abs(p) < Math.abs(p_)) {
									
									pi = { x: Math.abs(p) * .75, y: p * .5, o: Math.abs(p) * .5 }
								
								} else {

									pi = { x: Math.abs(p) - Math.abs(p_) * .25, y: p_ * .5, o: Math.abs(p) - Math.abs(p_) * .5 }

								}

							}

							if (j === 0) {

								// IF NEXT INDICATOR IS A SIBLING 
								if (issib) {

									// IF THERE IS NO CONTINUOUS INTERVAL RELATION WITH NEXT INDICATOR
									if (['interval'].indexOf(montagnes.meta[c].relationships.type) !== -1) {

										s +=	'M' + [0, 0] +
												'L' + [Math.abs(p) * .5, p]
										d.data.oa.push({ i: c, x: o, w: Math.abs(p) })
										o += pi.o

									} else if (['ordinal', 'nominal', 'ratio'].indexOf(montagnes.meta[c].relationships.type) !== -1) {

	 									s +=	'M' + [0, 0] +
												'L' + [Math.abs(p) * .5, p] +
												'L' + [pi.x, pi.y]
										d.data.oa.push({ i: c, x: o, w: Math.abs(p) })
										o += pi.o

									} 
									/*else if (['nominal', 'ratio'].indexOf(montagnes.meta[c].relationships.type) !== -1) {

										s +=	'M' + [0, 0] +
												'L' + [Math.abs(p) * .5, p] +
												'L' + [Math.abs(p), 0] +
												'Z' +
												'M' + [Math.abs(p), 0]
										d.data.oa.push({ i: c, x: o, w: Math.abs(p) })
										o += Math.abs(p)

									}*/

								} else {

									s +=	'M' + [0, 0] +
											'L' + [Math.abs(p) * .5, p] +
											'L' + [Math.abs(p), 0] +
											'Z' +
											'M' + [Math.abs(p), 0]
									d.data.oa.push({ i: c, x: o, w: Math.abs(p) })
									o += Math.abs(p)

								}

							} else if (j > 0 && j < montagnes.background.length - 1) {

								if (issib) {

									if (['interval'].indexOf(montagnes.meta[c].relationships.type) !== -1) {

										s +=	'L' + [Math.abs(p) * .5 + o, p] 
										d.data.oa.push({ i: c, x: o, w: Math.abs(p) })
										o += pi.o

									} else if (['ordinal', 'nominal', 'ratio'].indexOf(montagnes.meta[c].relationships.type) !== -1) {

	 									s +=	'L' + [Math.abs(p) * .5 + o, p] +
	 											'L' + [pi.x + o, pi.y]
	 									d.data.oa.push({ i: c, x: o, w: Math.abs(p) })
	 									o += pi.o

									} 

								} else {

									s +=	'L' + [Math.abs(p) * .5 + o, p] +
											'L' + [Math.abs(p) + o, 0] +
											'Z' +
											'M' + [Math.abs(p) + o, 0]
									d.data.oa.push({ i: c, x: o, w: Math.abs(p) })
									o += Math.abs(p)

								}

							} else {

								s +=	'L' + [Math.abs(p) * .5 + o, p] +
										'L' + [Math.abs(p) + o, 0] + 
										'Z'
								d.data.oa.push({ i: c, x: o, w: Math.abs(p) })

							}
						
						} else {

							s +=	'M' + [0, 0] +
									'L' + [Math.abs(p) * .5, p] +
									'L' + [Math.abs(p), 0] +
									'Z'
							d.data.oa.push({ i: c, x: 0, w: Math.abs(p) })

						}
					}
				})

				return s
			})
			.style('fill', function (d) {
				var color = d3.rgb('#333').brighter(d.index / 5)
				return color
			})

		




		






		var nestdata = d3.nest()
			.key(function (d) { return montagnes.meta[d].relationships.parent })
			.entries(montagnes.foreground)

		var mtns_foreground = pic_enter.selectAll('g.foreground')
			.data(nestdata)

		mtns_foreground.exit()
			.remove()
		
		var mtns_foreground_enter = mtns_foreground.enter()
			.append('g')
			.attr('class', 'foreground')
		
		mtns_foreground_enter = mtns_foreground_enter.merge(mtns_foreground)
			.moveToFront()
			.attr('transform', function (d) {

				var pathdata = d3.select(this.parentNode).select('path.background').datum(),
					ip = montagnes.background.indexOf(d.key),
					no = pathdata.data.oa[ip]

				return 'translate(' + [no.x, 0] + ')'
			})

		var path_foreground = mtns_foreground_enter.selectAll('path')
			.data(function (d) { return d.values })

		path_foreground.exit()
			.remove()

		var path_foreground_enter = path_foreground.enter()
			.append('path')

		path_foreground_enter = path_foreground_enter.merge(path_foreground)

		path_foreground_enter.transition()
			.duration(1000)
			.ease(d3.easeCubic)
			.attr('d', function (d, i) { 

				var s = '',
					parentdata = d3.select(this.parentNode).datum(),
					pathdata = d3.select(this.parentNode.parentNode).select('path.background').datum(),
					r_ = 0

				for (var j = 0; j < i; j++) {

					r_+= pathdata.data[parentdata.values[j]] / pathdata.data[parentdata.key]

				}
			
				var p = montagnes.yscale(parseFloat(pathdata.data[d])),
					pp = montagnes.yscale(parseFloat(pathdata.data[montagnes.meta[d].relationships.parent])),
					r = (pathdata.data[d] / pathdata.data[montagnes.meta[d].relationships.parent]) + r_

				if (pp === 0) return null

				s =	'M' + [0, 0] +
					'L' + [Math.abs(pp) - Math.abs(pp * .5) * r, pp * r] +
					'L' + [Math.abs(pp) - Math.abs(pp * .5) * r_, pp * r_] +
					'Z'
				
				/*
				s =	'M' + [no.x, 0] +
					'L' + [Math.abs(no.w) * .5, p + o] +
					'L' + [Math.abs(no.w), 0] +
					'L' + [Math.abs(no.w) * .5, o] +
					'Z'
				*/
				
				return s

			})
			.style('fill', function (d, i) {
				var pathcolor = d3.select(this.parentNode.parentNode).select('path.background').style('fill'),
					color = d3.rgb(pathcolor).brighter(i * .25)
				return color
			})


		var label = pic_enter.selectAll('g.label')
			.data(function (d, i) { return [d] })
		
		var label_enter = label.enter()
			.append('g')
			.attr('class', 'label')
		
		label_enter = label_enter.merge(label)
			.attr('transform', function (d, i) {
				if (!montagnes.background.length) return 'translate(' + [0, 0] + ')'
				return 'translate(' + [	
					-montagnes.yscale(parseFloat(d.data[montagnes.background[0]])) / 2, 
					montagnes.yscale(parseFloat(d.data[montagnes.background[0]])) - 65
					//(Math.abs(montagnes.yscale(parseFloat(d.data[montagnes.background[0]])) % 20) + 1) * -19
				] + ')'
			})

		var line = label_enter.selectAll('line.link')
			.data([0])
		
		var line_enter = line.enter()
			.append('line')
			.attr('class', 'link')
		
		line_enter = line_enter.merge(line)
			.attr('x1', 0)
			.attr('x2', 0)
			.attr('y1', 66)
			.attr('y2', 20)

		var txt = label_enter.selectAll('text.label')
			.data(function (d, i) { return [d] })

		var txt_enter = txt.enter()
			.append('text')
			.attr('class', 'label')

		txt_enter = txt_enter.merge(txt)
			.attr('x', 5)
			.attr('y', 15)
			.text(function (d) { return d.data.Commune_court })
		
		var bgbox = label_enter.selectAll('rect.label-box')
			.data(function () { return [d3.select(this).select('text.label').node().getBBox()] })
		
		var bgbox_enter = bgbox.enter()
			.insert('rect', 'text')
			.attr('class', 'label-box')

		bgbox_enter = bgbox_enter.merge(bgbox)
			.attr('width', function (d) { return d.width + 10 })
			.attr('height', 20)
			.attr('x', 0)
			.attr('y', 0)

			
	}
	menu.draw = function () {
		var m = d3.select('body')
			.append('div')
			.attr('class', 'menu')
		.append('div')
			.attr('class', 'inner')
		
		l = m.selectAll('div.indicateur')
			.data(menu.indicateurs)
		
		l.enter()
			.append('div')
			.attr('class', 'indicateur')
		.merge(l)
			.html(function (d) { return d })
			.on('click', function (d) {
				var domNode = d3.select(this)

				// IF NEW ENTRY HAS RELATIONSHIPS
				if (montagnes.meta[d].relationships) {
					// IF IT HAS NO PARENT
					if (!montagnes.meta[d].relationships.parent) {

						if (montagnes.background.indexOf(d) === -1) montagnes.background.push(d)
						else montagnes.background.splice(montagnes.background.indexOf(d), 1)
					// IF IT HAS A PARENT
					} else {
						// IF IT IS ALREADY IN THE FOREGROUND
						if (montagnes.foreground.indexOf(d) !== -1) {

							montagnes.foreground.splice(montagnes.foreground.indexOf(d), 1)

						} else {
							// IF THE LAST INDICATOR SELECTED IS A SIBLING
							var prev = montagnes.indicateurs[montagnes.indicateurs.length - 1]
							
							if (montagnes.meta[d].relationships.siblings.indexOf(prev) !== -1) {
								// IF THE SIBLING IS NESTED
								//if (montagnes.foreground.filter(function (c) { return montagnes.meta[d].relationships.siblings.indexOf(c) !== -1 }).length > 0) {
								if (montagnes.foreground.indexOf(prev) !== -1)	{
									
									montagnes.foreground.push(d)

								} else {

									montagnes.background.push(d)

								}

							} else if (prev === montagnes.meta[d].relationships.parent) {

									montagnes.foreground.push(d)

							} else {

								if (montagnes.background.indexOf(d) === -1) montagnes.background.push(d)
								else montagnes.background.splice(montagnes.background.indexOf(d), 1)

							}


						}

					}

				}

				if (montagnes.indicateurs.indexOf(d) === -1) montagnes.indicateurs.push(d)
				else montagnes.indicateurs.splice(montagnes.indicateurs.indexOf(d), 1)
				//console.log(montagnes.indicateurs, montagnes.background, montagnes.foreground)

				montagnes.draw()
				raisonnement.draw()
				var s = toggle.class(this, 'select')
				if (s) domNode.html(d + ' (pic #' + (montagnes.background.indexOf(d) + 1) + ')')
				else domNode.html(d)
			})
	}
	carte.draw = function () {
		var z = 1,
			mr = d3.select('div.menu').node().getBoundingClientRect()
		carte.w = mr.width 
		carte.h = mr.width * .75

		// UPDATE THE .menu .inner HEIGHT TO ENSURE SCROLL
		d3.select('div.menu .inner').style('max-height', 'calc(100vh - ' + carte.h + 'px - 2em)')

		carte.projection = d3.geoMercator()
			.fitExtent([[0, 0], [carte.w, carte.h]], carte.data)
		carte.path = d3.geoPath()
			.projection(carte.projection)

		var svg = d3.select('div.menu')
			.insert('svg', ':first-child')
			.attr('class', 'carte')
			.attr('width', carte.w)
			.attr('height', carte.h)
		.append('g')
			//.attr('transform', 'translate(' + [montagnes.w - montagnes.w * montagnes.p, montagnes.h * montagnes.p / 4] + ')')

		svg.selectAll('path')
			.data(carte.data.features)
		.enter()
			.append('path')
			.classed('active', true)
			.attr('d', carte.path)
		.on('mouseover', function (d) {
			toggle.class(this, 'highlight')
			d3.selectAll('g.pic').filter(function (c) { return c.Commune_strip === d.properties.NOM })
				.selectAll('.mont path').classed('highlight', true)
		})
		.on('mouseout', function (d) {
			toggle.class(this, 'highlight')
			d3.selectAll('g.pic').filter(function (c) { return c.Commune_strip === d.properties.NOM })
				.selectAll('.mont path').classed('highlight', false)
		})
		.on('pointerup', function (d) {
			if (montagnes.communes.indexOf(d.properties.NOM) !== -1) montagnes.communes.splice(montagnes.communes.indexOf(d.properties.NOM), 1)
			else montagnes.communes.push(d.properties.NOM)

			console.log(d)

			toggle.class(this, 'active')
			montagnes.draw()
		})
	}
	
	raisonnement.draw = function () {


		var svg = d3.select('svg.paysage')
		raisonnement.h = montagnes.h * montagnes.p,
		raisonnement.w = (montagnes.w - montagnes.w * montagnes.p) - (montagnes.w * montagnes.p)
		raisonnement.r = 30
		raisonnement.p = raisonnement.r

		raisonnement.pack = d3.pack()
			.size([raisonnement.r, raisonnement.r])
		
		var tm = montagnes.background.map(function (d) {

			var obj = {}
			obj.name = d
			var children = montagnes.foreground.filter(function (c) { return montagnes.meta[c].relationships.parent === d })
				.map(function (c) {
					return { name: c, size: 1 }
				})
			children.length ? obj.children = children : obj.size = 1
			return obj

		})

		var g = svg.selectAll('g.raisonnement')
			.data([0])

		var g_enter = g.enter()
			.append('g')
			.attr('class', 'raisonnement')
			.attr('transform', 'translate(' + [0, montagnes.h - montagnes.h * montagnes.p] + ')')

		g_enter.append('line')
			.attr('x1', montagnes.w * montagnes.p)
			.attr('x2', montagnes.w - montagnes.w * montagnes.p)
			.attr('y1', raisonnement.h / 2)
			.attr('y2', raisonnement.h /2)
		
		g_enter = g_enter.merge(g)

		var node_group = g_enter.selectAll('g.node-group')
			.data(tm, function (d) { return d.name })

		node_group.exit()
			.remove()

		montagnes.groupes = []
		montagnes.indicateurs.forEach(function (d, i) {
			if (montagnes.foreground.indexOf(d) === -1) {
				if (i > 0) {
					var prev = montagnes.indicateurs[i -1],
						prevsib = montagnes.meta[prev].relationships.siblings
					if (prevsib.indexOf(d) !== -1) montagnes.groupes[montagnes.groupes.length - 1].push(d)
					else montagnes.groupes.push([d])
				} else {
					montagnes.groupes.push([d])
				}
			}
		})

		var node_group_enter = node_group.enter()
			.append('g')
			.attr('class', 'node-group')
			.attr('transform', function (d, i) {
				var bin = 0,
					idx = 0
				montagnes.groupes.forEach(function (c, j) {
					if (c.indexOf(d.name) !== -1) {
						bin = j
						idx = c.indexOf(d.name)
					}
				})
				var x = bin * raisonnement.w / (montagnes.groupes.length - 1 > 1 ? montagnes.groupes.length - 1 : 1) + (bin === montagnes.groupes.length - 1 ? (idx - (montagnes.groupes[bin].length - 1)) * raisonnement.r / 2 : idx * raisonnement.r / 2)
				d.x = montagnes.w * montagnes.p + x - raisonnement.r / 2
				d.y = raisonnement.h / 2 - raisonnement.r / 2
				return 'translate(' + [d.x, d.y] + ')'
			})

		node_group_enter = node_group_enter.merge(node_group)
			.classed('shifted', false)
			.call(raisonnement.drag)

		node_group_enter.transition()
			.duration(500)
			.ease(d3.easeCubic)
			.attr('transform', function (d, i) {
				var bin = 0,
					idx = 0
				montagnes.groupes.forEach(function (c, j) {
					if (c.indexOf(d.name) !== -1) {
						bin = j
						idx = c.indexOf(d.name)
					}
				})
				var x = bin * raisonnement.w / (montagnes.groupes.length - 1 > 1 ? montagnes.groupes.length - 1 : 1) + (bin === montagnes.groupes.length - 1 ? (idx - (montagnes.groupes[bin].length - 1)) * raisonnement.r / 2 : idx * raisonnement.r / 2)
				d.x = montagnes.w * montagnes.p + x - raisonnement.r / 2
				d.y = raisonnement.h / 2 - raisonnement.r / 2
				return 'translate(' + [d.x, d.y] + ')'
			})

		var node = node_group_enter.selectAll('g.node')
			.data(function (d) {
				var p = d3.hierarchy(d)
					.sum(function (d) { return d.size })
					.sort(function (a, b) { return b.value - a.value })
				return raisonnement.pack(p).descendants()
			})

		node.exit()
			.remove()

		var node_enter = node.enter()
			.append('g')
			.attr('class', 'node')
			.attr('transform', function (d) {
				return 'translate(' + [d.x, d.y] + ')'
			})

		node_enter = node_enter.merge(node)
			.classed('highlight-parent', false)
			.classed('highlight-sibling', false)
			.classed('highlight-fill', false)

		node_enter.transition()
			.duration(500)
			.ease(d3.easeCubic)
			.attr('transform', function (d) {
				return 'translate(' + [d.x, d.y] + ')'
			})
			.style('fill', function (d, i) {
				var color = d3.rgb('#333').brighter(i)
				return color
			})

		var circle = node_enter.selectAll('circle')
			.data(function (d) { return [d] })
		
		circle.exit()
			.remove()

		var circle_enter = circle.enter()
			.append('circle')
			.attr('r', 0)

		circle_enter = circle_enter.merge(circle)

		circle_enter.transition()
			.duration(500)
			.ease(d3.easeCubic)
			.attr('r', function (d) { return d.r })
	}

	raisonnement.drag = d3.drag()
		.on('start', function (d) {
			d3.select(this).moveToFront()

			d3.selectAll('g.node').each(function (c) {
				var thisNode = d3.select(this)
				if (c.data.name === montagnes.meta[d.name].relationships.parent) {
					thisNode.classed('highlight-parent', true)
						.transition()
						.duration(100)
						.ease(d3.easeCubic)
						.attr('transform', 'translate(' + [c.x, c.y] + ')scale(2)')
				}

			})
		})
		.on('drag', function (d) {
			var evt = d3.event,
				domNode = this
			// MOVE THE SELECTED NODE ALONG THE X AXIS
			d.x += evt.dx
			d.x <= montagnes.w * montagnes.p - raisonnement.r / 2 ? d.x = montagnes.w * montagnes.p - raisonnement.r / 2 : d.x = d.x
			d.x >= montagnes.w - (montagnes.w * montagnes.p) - raisonnement.r / 2 ? d.x = montagnes.w - (montagnes.w * montagnes.p) - raisonnement.r / 2 : d.x = d.x
			d3.select(this).attr('transform', 'translate(' + [d.x, d.y] + ')')
			// DETERMINE POSITION OF GROUPS
			//montagnes.groupes.forEach(function (c, j) {
			//	if (c.indexOf(d.name) !== -1) {
			//		bin = j
			//		idx = c.indexOf(d.name)
			//	}
			//})
			var bins = montagnes.groupes.map(function (c, j) {
				var x = 0
				if (c.length === 1) x = j * raisonnement.w / (montagnes.groupes.length - 1 > 1 ? montagnes.groupes.length - 1 : 1)
				else {
					x = j * raisonnement.w / (montagnes.groupes.length - 1 > 1 ? montagnes.groupes.length - 1 : 1) + (j === montagnes.groupes.length - 1 ? -(c.length - 1) / 2 * raisonnement.r / 2 : (c.length - 1) / 2 * raisonnement.r / 2)
				}
				return montagnes.w * montagnes.p + x - raisonnement.r / 2
			})

			bins.forEach(function (c, j) {
				if (d.x <= c + raisonnement.p && d.x >= c - raisonnement.p) {
					d3.selectAll('g.node-group:not(.shifted)').filter(function (b) { 
						return montagnes.groupes[j].indexOf(b.name) !== -1 
							&& domNode !== this 
							&& !d3.select(this).select('g.node').classed('highlight-parent')
					})
						.classed('shifted', true)
						.transition()
						.duration(100)
						.ease(d3.easeCubic)
						.attr('transform', function (b, k) {
							// MAYBE DO SOMETHING WITH THE BINS, ie WHEN IT INTERSECTS WITH BINS OF MULTIPLE NODES THEN SPLIT THE NODES
							if (b.x > c) b.x += raisonnement.r
							else if (b.x < c) b.x -= raisonnement.r
							else if (b.x === c) b.x = b.x
							return 'translate(' + [b.x, b.y] + ')'
						})
				} else {
					d3.selectAll('g.node-group.shifted').filter(function (b) { 
						return montagnes.groupes[j].indexOf(b.name) !== -1 
							&& domNode !== this 
					})
						.classed('shifted', false)
						.transition()
						.duration(100)
						.ease(d3.easeCubic)
						.attr('transform', function (b, k) {
							var x = j * raisonnement.w / (montagnes.groupes.length - 1 > 1 ? montagnes.groupes.length - 1 : 1) + (j === montagnes.groupes.length - 1 ? (k - (montagnes.groupes[j].length - 1)) * raisonnement.r / 2 : k * raisonnement.r / 2)
							b.x = montagnes.w * montagnes.p + x - raisonnement.r / 2
							return 'translate(' + [b.x, b.y] + ')'
						})
				}
			})
			// MOVE NODES IF OVERLAPPING

			/*var n = d3.selectAll('g.node-group').filter(function (c) {
				return d.x <= c.x + raisonnement.p && d.x >= c.x - raisonnement.p && domNode !== this && !d3.select(this).select('g.node').classed('highlight-parent')
			})
			n.transition()
				.duration(100)
				//.ease(d3.easeCubic)
				.attr('transform', function (c) {
					// MAYBE DO SOMETHING WITH THE BINS, ie WHEN IT INTERSECTS WITH BINS OF MULTIPLE NODES THEN SPLIT THE NODES
					return 'translate(' + [(d.x >= c.x ? c.x - raisonnement.r : c.x + raisonnement.r), c.y] + ')'
				})
			var n_ = d3.selectAll('g.node-group').filter(function (c) {
				return !(d.x <= c.x + raisonnement.p && d.x >= c.x - raisonnement.p) && domNode !== this && !d3.select(this).select('g.node').classed('highlight-parent')
			})
			n_.transition()
				.duration(100)
				//.ease(d3.easeCubic)
				.attr('transform', function (c) {
					return 'translate(' + [c.x, c.y] + ')'
				})*/
			// IF THE OVERLAPPED NODE IS PARENT
			var pn = d3.selectAll('g.node-group').filter(function (c) {
				return d.x <= c.x + raisonnement.p && d.x >= c.x - raisonnement.p && domNode !== this && d3.select(this).select('g.node').classed('highlight-parent')
			})
			pn.select('g.node').classed('highlight-fill', true)
		})
		.on('end', function (d) {
			var ps = [],
				domNode = this
			
			// IF THE OVERLAPPED NODE IS PARENT
			var pn = d3.selectAll('g.node-group').filter(function (c) {
				return d.x <= c.x + raisonnement.p && d.x >= c.x - raisonnement.p && domNode !== this && d3.select(this).select('g.node').classed('highlight-parent')
			})
			if (pn.size()) {

				montagnes.background.splice(montagnes.background.indexOf(d.name), 1)
				montagnes.foreground.push(d.name)
				montagnes.indicateurs = shiftArr(montagnes.indicateurs, montagnes.indicateurs.indexOf(d.name), montagnes.indicateurs.indexOf(montagnes.meta[d.name].relationships.parent) + 1)
				
			} else {

				d3.selectAll('.node circle').filter(function () { return domNode !== this.parentNode.parentNode })
					.each(function (c) {
						// IF THE NODE IS IN THE FOREGROUND
						if (!c.data.x) ps.push(ps[ps.length - 1])
						else ps.push(c.data.x)
					})

				var bisection = d3.bisect(ps, d.x)
				if (d.x <= d3.min(ps)) bisection = d3.bisectLeft(ps, d.x)
				if (d.x >= d3.max(ps)) bisection = d3.bisectRight(ps, d.x)

				// CHANGE THE MAIN INDICATOR ARRAYS
				montagnes.indicateurs = shiftArr(montagnes.indicateurs, montagnes.indicateurs.indexOf(d.name), bisection)
				montagnes.background = shiftArr(montagnes.background, montagnes.background.indexOf(d.name), bisection)
			}

			raisonnement.draw()
			montagnes.draw()
		})





	toggle.class = function (node, c) {
		var domNode = d3.select(node)
		domNode.classed(c, domNode.classed(c) ? false : true)
		return domNode.classed(c)
	}

</script>

</body>

</html>